Operating Systems, Spring 2021, Exercise 6 (Lectures 11-12)  
 
1. File access. Consider a file with 4 million records. How many record (file) accesses 
on average are required to search for a particular key in each of the following cases?  
(a)  In a sequential file with all 4 million records.  
(b)  In an indexed sequential file with an index containing 2000 entries (with the keys 
in the index equally distributed over the main file).  
(c)  In an indexed sequential file with multiple levels of indexing, where the lower-
level index has 40 000 entries and a higher-level index for the lower-level index has 
200 entries.  
a) On average 2,000,000 accesses 
 
b) It will take on average 1000 accesses to find the key and then 1000 accesses in the main 
file, so the average is 2000 
 
c) It will take on average 100 entries to find the higher-level key and then lower level takes 
50 entries and finally main file takes 50 entries, so the average is 200. 
 
2. UNIX file management. Read Chapter 12.8 [Stalling, 2018, pp. 580-585] and answer the 
following questions. Consider the organization of UNIX file as represented by the inode (see 
Figure 12.15). Assume there are 12 direct block pointers, and a singly, doubly, and triply 
indirect pointer to each inode. Assume further that the system block size and the disk sector 
size are both 8 KB, and the disk block pointer is 32 bits, with 8 bits to identify the physical 
disk and 24 bits to identify the physical block.  
 
(a) What is the maximum file size supported by this system?  
 
(b) What is the maximum system partition supported by this system?  
 
(c) Assuming no information other than the the file inode is already on the main memory, 
how many disk accesses are required to access the byte in position 13 423 956?  
 
a) 
 
 
 
b) 
 
(8*2^32)/1024^3=32G 
 
2^24*8k=16M*8K=1073741824000 bits = 128GB 
 
 
c) Given address corresponds to first indirect block. This is singe indirect pointer and 
therefore two disk accesses are required. One for the first indirect block and one for the block 
containing the required data. 
 
 
 
3. Buffer overflows.  
(a)  What are the two broad categories of defences against buffer overflows?  
• Compile-time defences, which aim to harden programs to resist attacks in new 
programs  
• run-time defences, which aim to detect and abort attacks in existing programs 
(b)  List and briefly describe some of the defences against buffer overflows that can be 
used when compiling new programs?  
• Modern safe programming language  
• Safe programming techniques such as buffer validation and range checks 
• Safe libraries and stack protection mechanisms 
Kb
Bytes
Bits
1
1024
8192
4
4096
32768
8
8192
65536
Address
2048
Number of blocks Number of Bytes
Direct
12
96 KB
Single indirect
2048
16384 16MB
Double indirect
4096
32768 32GB
Triple indirect
8192
65536 64TB
Sum
64,03216TB
(c)  List and briefly describe some of the defences against buffer overflows that can be 
used when running existing, vulnerable programs?  
• Executable address space protection meaning that no-execute bits are set on memory 
management unit to block code execution of pages in virtual memory 
• Address space randomization meaning that address of the buffer is changed randomly 
and thus stack and heap are located randomly for each process 
• Guard pages which are pages located in critical regions of memory and thus any 
attempt to access them is blocked 
(d)  Why do you need run time defences against vulnerable programs and not just 
recompile all code?  
• Because some programming languages like C are vulnerable to buffer overflows that 
can happen when existing programs are running and thus it’s impossible to prevent all 
the attacks in compiling. 
 
4. UNIX passwords. Assume that UNIX passwords are limited to the use of the 95 
printable ASCII characters and that all passwords are 10 characters in length.  
(a)  Assume a password cracker with a 4-core system and an encryption rate of 6 
million encryptions per second in each core. How long will it take to test exhaustively 
all possible passwords?  
(b)  What if the intruder has a 1000 node cluster with 8 cores (the same speed as 
above) in each cluster? How long does it take now?  
(c)  What if each cluster node would have a 2000 core graphics card (the same speed 
as above) to crack your password? How long does it take now?  
(d)  What if the attacker knows that the user is lazy and uses only (upper and lower 
case) letters in his password? You can assume the English alphabet with 26 letter. 
How long does it take now (with the cluster and the graphics cards)?  
 
a)
Permutations
36668784925297300000
cores
4
Millions of encryptions per second per core
6000000
Millions of encryptions per second total
24000000
Seconds to guess
1527866038554
Minutes to guess
25464433976
Hours
424407233
Days
17683635
Years
48448
b)
Permutations
36668784925297300000
cores
8000
Millions of encryptions per second per core
6000000
Millions of encryptions per second total
48000000000
Seconds to guess
763933019
Minutes to guess
12732217
Hours
212204
Days
8842
Years
24
c)
Permutations
36668784925297300000
cores
2000000
Millions of encryptions per second per core
6000000
Millions of encryptions per second total
12000000000000
Seconds to guess
3055732
Minutes to guess
50929
Hours
849
Days
35
Years
0
d)
Permutations
19275223968000
cores
8000
Millions of encryptions per second per core
6000000
Millions of encryptions per second total
48000000000
Seconds to guess
402
Minutes to guess
7
Hours
0
Days
0
Years
0
Permutations
19275223968000
cores
2000000
Millions of encryptions per second per core
6000000
Millions of encryptions per second total
12000000000000
Seconds to guess
2
Minutes to guess
0
Hours
0
Days
0
Years
0
5. UNIX access control. Read Chapter 15.4 [Stallings, 2018, pp. 678-681] In 
traditional UNIX file access model, UNIX systems provide a default setting for newly 
created files and directories, which the owner may later change. The default is 
typically full access for the owner combined with one of the following: no access for 
group and other, read/ execute access for group and none for other, or read/execute 
access for both group and other. Briefly discuss the advantages and disadvantages of 
each of these cases, and provide an example for each case that would be appropriate.  
• No access for group and other: Only the owner is able to access the directories 
and access for others must be explicitly granted. This could be the case when 
information is considered private such as in business environments. 
• Read/ execute access for group and none for other: This approach could be 
used for example in cases where some people in the organization need the 
access and others don’t while working in the same environment. 
• Read/execute access for both group and other: This approach could be used for 
example in small businesses where people know and trust each other’s. 
